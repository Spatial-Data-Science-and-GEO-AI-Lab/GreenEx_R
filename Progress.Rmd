---
title: "Progress"
author: "Martijn Koster"
date: "2023-05-08"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Week 1

### Goal

The goal of this week was to write 2 functions for the package

* Function 1: Average NDVI in the buffer around the point/polygon (house) given coordinates 
* Function 2: Land cover percentage in the buffer around the point/polygon (house) given coordinates

### Approach

A large part of the code is already written by Karen, this code needs to be understood and written in a package form using `devtools` and `roxygen2`

* Run the code provided and understand what is done and why
* Adapt this code if necessary, and put it in a devtools package. 

### Feedback

* Make no data is lost when returning the function (i.e., the geometries etc should be returned also)
* make sure that when a polygon is given as input data, they also provide a buffer. (Use a `else if` statement)


## Week 2: 

### Goal

* make sure the feedback is handled with
* Create a function for vector on vector. What percentage of for example parks in the polygon of the house
* Figrure out how to make `GVI` package part of this package
* If time over start with the accessibility function

### Approach

* start with the feedback of last week
* make the function for vector on vector, most of the code that is already written can be used. make use of the test data to test the code
* Investigate with help of chatGPT, stackoverflow/stack exchange how to incorporate the `GVI` package in this package. Start with reading the documentation

### Difficulties

* Still have some troubles with the crs of the buffer around the address points. 
* regarding the polygons, how do we want the coordinates, with or without decimals
* Code I am not 100% certain of: 
```{r, include=FALSE}
landcover_test <- terra::rast("Data/Landcover_data_test.tif")
address_test <- sf::st_read("Data/Test_multiple_home_locations.gpkg")
address_test$id <- nrow(address_test):1
area_test <- sf::st_read("Data/TestArea.gpkg")
buffer_distance <- 500
source("R/green_cover.R")
source("R/average_ndvi.R")
library(tidyverse)
ndvi_test <- terra::rast("data/NDVI_data_test.tif")


```

*This code I am using to set the crs to the projected crs (otherwise the polygon did not have the crs when returned in the function)*

`calculation_area <- sf::st_as_sf(sf::st_sfc(iso_poly)) %>% sf::st_set_crs(projected_crs)`

```{r, include=FALSE}

# I am using the second column in this buffer to get the coordinates, otherwise I would get the ID as well.
calculation_area <- sf::st_buffer(address_test, dist = buffer_distance)[2]
address <- address_test[2]
# This is how I gave the variables a name when returning the df
names(address) <- "address"
names(calculation_area) <- "buffer"
```

* How can I use the data frame created with the `calc_ndvi` function as input for `address_location` in the `land_cover` function and the other way around? 

example: 
```{r}
address_test
```

```{r}
a <- calc_ndvi(address_test, ndvi_test, speed=5, time = 10)
a
```

* **Discuss how the variables in the function should be returned **

### Progress

```{r}
result1 <- calc_ndvi(address_test, ndvi_test, speed=5, time=10)
```


```{r}
result2 <- land_cover(address_test, landcover_test, speed=5, time = 10)
result2 
```

```{r}
result3 <- inner_join(result1, result2)
result3
```




### Feedback

## Week 3



