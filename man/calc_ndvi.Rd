% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ndvi_calc.R
\name{calc_ndvi}
\alias{calc_ndvi}
\title{Creating average NDVI values per location}
\usage{
calc_ndvi(
  address_location,
  raster,
  buffer_distance = NULL,
  network_buffer = FALSE,
  folder_path_network = NULL,
  epsg_code = NULL,
  network_file = NULL,
  UID = NULL,
  address_location_neighborhood = FALSE,
  speed = NULL,
  time = NULL,
  add_sd = FALSE,
  engine = "pc",
  city = NULL,
  start_date = "2020-01-01",
  end_date = "2021-01-01",
  folder_path_ndvi = NULL,
  plot_NDVI = FALSE
)
}
\arguments{
\item{address_location}{A \code{\link[sf]{sf}} object representing the location of interest, the location should be in projected coordinates.}

\item{raster}{Optional; a object of class \code{\link[terra]{rast}} with NDVI values}

\item{buffer_distance}{A distance in meters to create a buffer or isochrone around the address location}

\item{network_buffer}{Optional; a logical, the default is an euclidean buffer, when TRUE, a network buffer will be used.}

\item{folder_path_network}{Optional; Folder path to where the retrieved network should be saved continuously. Must not include a filename extension (e.g. '.shp', '.gpkg').}

\item{epsg_code}{Optional; a  espg code to get a Projected CRS in the final output, If missing, the default is \code{3395}}

\item{network_file}{Optional; a \code{\link[sfnetworks]{sfnetwork}} object representing a road network, If missing the road network will be created.}

\item{UID}{Optional; a  character string representing a unique identifier for each point of interest}

\item{address_location_neighborhood}{Optional; a  logical, indicating whether to calculate with an address point or a neighborhood. default is \code{FALSE}}

\item{speed}{Optional; a  numeric value representing the speed in km/h to calculate the buffer distance (required if \code{time} is provided)}

\item{time}{Optional; a  numeric value representing the travel time in minutes to calculate the buffer distance (required if \code{speed} is provided)}

\item{add_sd}{Optional; returns the standard deviation of the NDVI values within a buffer.}

\item{engine}{Optional; When the raster is missing, users can choose whether they want to use Google Earth engine \code{gee} or Planetary Computer \code{pc} to calculate the ndvi}

\item{city}{Optional; when using a network buffer, you can add a city where your address points are to speed up the process}

\item{start_date}{Optional; The start date from when the satellite images will be filtered \code{yyyy-mm-dd} default = \code{2020-01-01}}

\item{end_date}{Optional; The end date from when the satellite images will be filtered. \code{yyyy-mm-dd} default = \code{2021-01-01}}

\item{folder_path_ndvi}{Optional; Folder path to where the retrieved network should be saved continuously. Must not include a filename extension}

\item{plot_NDVI}{Optional; if you want to plot the NDVI, default is \code{FALSE}}
}
\value{
A \code{sf} dataframe with the mean ndvi, the geometry and the buffer that was used
}
\description{
Creating average NDVI values per location
}
\examples{
# Read a dataset, in this instance we will use the first ten neighborhoods from the
# Ams_Neighborhood dataset, which contains polygon geometry
df <- Ams_Neighborhoods[1:10,]

# calculate the mean ndvi for the neighborhoods with default settings
calc_ndvi(df, buffer_distance=300)

# calculate the mean ndvi for the neighborhoods, using the neigborhood as buffer
calc_ndvi(df, address_location_neighborhood = TRUE)

# calculate the mean and sd ndvi for the centroid neighborood, using the network as buffer
calc_ndvi(df, buffer_distance=300, network_buffer=TRUE, add_sd=TRUE)

}
